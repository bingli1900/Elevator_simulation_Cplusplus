// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//
//
//---------------------------ELEVATOR TEST LIBRARY------------------------------------------------
//
//Final project for mpcs51044 "C++ for advanced programmer"
//
//by Bing Li
//
//simulating the operation of elevators algorithms
// 1) assumptions:
//    (1) people will wait until the elevator comes once they enter the queue 
//
//    (2) time is quantum, elevator will move by one floor up or down in each 
//        time quantum; and if the elevator is static, then it'll take one quantum
//        of time for each person to get on or off;  
//
//    (3) the building has 20 floors (0,1,2,3,4,...19) and n elevators (n can be 1,2,3...)
//        so in this setting, we would have 18*2+1+1 = 38 buttons on floors and 20 in each elevator.
//
// 2) Additional assumptions, like:
//	  if elevators are independent or not:
//	     the strategy of each elevator can be independent from each other;
//       the people waiting for one elevator won't take another elevator
//    should say that a good algorithm should consider the cooperation between elevators.
//
// 3) independent elevators are candidates to apply multi-threads;
//    we can also apply multi-threads with the statistics class, different threads deal with
//    different input event flows(generated by Monte Carlo). 
//    Use a bunch of event flows, we can solve problems like "How
//    long on average do I have to wait, if I want to take the elevator from floor i
//    to floor j in a rush period?"
//
// 4) another possibility to solve this problem is to compute analytically;
//    don't instantiate individual human being and floor as an object in the solution, 
//    but rather use matrix element Mij to stand for if there is any person in a queue. 
//    Mij is the num of people who wants
//    to move from level i to level j.
//
//-----------------------------------------------------------------------------------------------
//
//	The basic logic or hierarchy structure of this project is as follows:
//
//  All classes: QuanTimer, Elevator, Floor, Algorithm, Statistics, Person 
//
//
//       Alg and Stat are members of            (time_step function)
//          ---------------------------------->     QuanTimer  (control time flow/coordinate all classes)                   
//          |           |                           | ^                     ^
//          |           |     determines            | | (button pressed)     \ update "button pressed" information
//          |           | Elevator's next state     V |                       \
//          |       Algorithm--------------->   Elevator  <====================> Floor (20 floors, each has two queues,
//          |  (can derive diff algs)     (moving and talking to current floor) /  ^               up and down)
//          |                                            \                     /   |
//          |                                             \                   /    |
//      Statistics ---------------------------------------> --> Person   <----     |
//          |     record each person's getting on and off                          |
//          |                                                                      |
//          |-----------------------------------------------------------------------
//             (generate "task queues" at each floor, like "who comes at which
//                 floor at what time and going towards which floor)
//
//-----------------------------------------------------------------------------------------------
//
//	The most important member functions are:
//         1. QuanTimer::time_step()
//         2. Elevator::update()
//         3. Algorithm::processing()
// 
//-----------------------------------------------------------------------------------------------
#pragma once
#include <iostream>       // std::cin, std::cout
#include <queue>          // std::queue
#include <map>
#include <set>
#include <vector>
#include <algorithm>
#include <string>
#include <functional>
#include <list>
#include <iomanip>
#include <cmath>

using std::queue;
using std::list;
using std::map;
using std::set;
using std::vector;

namespace elevator_51044_final{

	
	int const FLOOR_NUM = 20;           //define how many floors there are in this building
	int const ELEVATOR_CAPACITY = 13;   //define the maximum capacity of an elevator

	//plan and analysis: 
	//1. how to maximize the independency between each class
	//   different classes share buffer
	//
	//2. how to extend to multithreaded version and keep concurency

	enum Direction{
		//this type is labeling the state of an elevator or a customer
		UP,
		DOWN,
		SLEEP
	};

	void print_matrix(double *a){
		for (int i = 0; i < FLOOR_NUM; i++){
			for (int j = 0; j < FLOOR_NUM; j++){
				std::cout << std::setw(4) << *(a + FLOOR_NUM*i + j) << " ";
			}
			std::cout << std::endl;
		}
	}


	class Statistics{
		//friend class QuanTimer;
		friend class Person;
	public:
		Statistics(){
			num_people = 0;
			total_waiting_time = 0;
			busy_time = 0;
			free_time = 0;
			busy_ratio = 0.;
			average_waiting_time = 0.;
			for (int i = 0; i < FLOOR_NUM; i++)
				for (int j = 0; j < FLOOR_NUM; j++){
					waiting_matrix[i][j] = 0;
					num_people_matrix[i][j] = 0;
					average_waiting_time_matrix[i][j] = 0.;
				}
		}

		void processing();
		void printResult() const;

	private:
		//average waiting time
		int num_people;
		int total_waiting_time;
		int waiting_matrix[FLOOR_NUM][FLOOR_NUM];
		int num_people_matrix[FLOOR_NUM][FLOOR_NUM];

		//calculate the busy-free ratio of the elevator
		int busy_time;
		int free_time;
		double busy_ratio;

		//the matrix method
		double average_waiting_time;
		double average_waiting_time_matrix[FLOOR_NUM][FLOOR_NUM];
	};


	//elevator algorithm demands several inputs and the algorithm is to
	//determine realtime which elevator stop at which floor, this output
	//should get updated each time a button is hit.
	//inputs: 
	//      1. states of all elevators: going up or down; which floor;
	//                complex algorithm can also include information like
	//                how many time this elevator has been interupted,
	//      2. states of all buttons:   if there is need at any floor to 
	//                go up or down; how long has this button been pressed;
	//                i.e. the order that these button were pressed
	//      3. complex algorithm can also take historical info into account
	//
	//output:
	//      1. next stop for each elevator
	// 
	//this class is a base class, can be inherited, i.e. be written into
	//with different kinds of algorithms. Derivative algorithm class has to 
	//override 3 functions:  processing / nestStop / upOrDown .
	class AlgorithmBase{
	public:
		AlgorithmBase(){};

		//update function is used to transfer all current information to the algorithm
		//including all button on/off infor, elevator button info and current state of the elevator
		void update(bool *fu, bool *fd, bool *el, Direction dire, int floor, bool full){
			memcpy(bfloor_up, fu, FLOOR_NUM);
			memcpy(bfloor_down, fd, FLOOR_NUM);
			memcpy(belevator, el, FLOOR_NUM);
			current_floor = floor;
			direction = dire;
			elevator_full = full;
		}

		//the following 3 functions are all virtual, implementation needed for 
		//any particular algorithm.
		//the most processing work is done here
		virtual void processing(){};
		//return the next stop location and direction
		//this should be called after "update" and "procession" functions 
		virtual vector<int> nextStop(){ vector<int> a; return a; };
		virtual vector<Direction> upOrDown(){ vector<Direction> a; return a; };

		bool bfloor_up[FLOOR_NUM];
		bool bfloor_down[FLOOR_NUM];
		bool belevator[FLOOR_NUM];
		int current_floor;
		Direction direction;
		int nextstop;
		bool elevator_full;
	};


	//the most simple algorithm of a real elevator, but maybe the most popular one, 
	//
	//both fair and efficient
	//
	//assumption:
	//    1. There is only one elevator;
	//    2. elevator will keep its previous direction(UP or DOWN) as long as there is still
	//       task in this direction, no matter earlier or later this task might come compared
	//       to other tasks;
	//       i.e. elevator will not respond to tasks in strict order but prefer to go all the way
	//       up or down at each round.
	class Algorithm_SingleElevator_Simple : public AlgorithmBase{
	public:
		void processing() override;
		vector<int> nextStop() override;
		vector<Direction> upOrDown() override;
	};


	class Person{
	//can be seen as an event, record all the information about
	//where he is from and where he is going and when, and how long has he been
	//waiting, and finally what's his final disatisfaction.
	public:
		Person();
		Person(unsigned int i, unsigned int f, int time);
		bool goingUp() const {return goingup;}
		void print() const{
			std::cout << "Person: from " << original_floor
					<< " to " << destination_floor
					<< (goingup ? " going up" : " going down")
					<< std::endl;
		}
		~Person(){
		}

		void setOutTime(int time);
		int getInTime() const {return in_time;}
		unsigned int getDstFlr() const {return destination_floor;}
		unsigned int getOrgFlr() const {return original_floor;}

		void stat(Statistics &s){
			s.num_people += 1;
			s.total_waiting_time += (out_time - in_time + abs((long)destination_floor - (long)original_floor));
			s.waiting_matrix[original_floor][destination_floor] += (out_time - in_time + abs((long)destination_floor - (long)original_floor));
			s.num_people_matrix[original_floor][destination_floor] += 1;
		}

	private:
		unsigned int destination_floor;
		unsigned int original_floor;
		bool goingup;
		int in_time;
		int out_time;
	};



	class Floor{
	//each floor has two queues, up queue and down queue
	//two functions: 
	// 1 .
		friend class Elevator;
	public:
		Floor() : floor_num(0), button_up(false), button_down(false){};
		void Init(int &floor_number){ floor_num = floor_number;}
		void checkNewArrival(Person const &p, unsigned int const &time);

		Floor(unsigned int &floor_num, bool &button_up, bool &button_down) :
			floor_num(floor_num), button_up(false), button_down(false){}

		bool check_up(){
			update_up();
			return button_up;
		}

		bool check_down(){
			update_down();
			return button_down;
		}

		void update_up(){
			if (waiting_up.empty())
				button_up = false;
		}
		void update_down(){
			if (waiting_down.empty())
				button_down = false;
		}

	private:
		unsigned int floor_num;
		queue<Person> waiting_down;
		queue<Person> waiting_up;
		bool button_up;
		bool button_down;
	};
	


	class Elevator{

		friend class QuanTimer;
		//also have two queues
	public:
		Elevator(){
		//default initialization
			number = 0;
			vacancy = ELEVATOR_CAPACITY;
			thisfloor = 0;
			direction = SLEEP;
			full = false;
			for (int jj = 0; jj < FLOOR_NUM; jj++){
				buttons[jj] = false;
			}
		}

		Elevator(int i){
		//initialization
			number = i;
			vacancy = ELEVATOR_CAPACITY;
			thisfloor = 0;
			direction = SLEEP;
			full = false;
			for (int jj = 0; jj < FLOOR_NUM; jj++){
				buttons[jj] = false;
			}
		}

		Direction getDirection() const{return direction;}
		int getFloor() const { return thisfloor;}
		void get_in(Person const &p);
		void update(vector<int> nextStop, vector<Direction> dirs, Floor floors[], Statistics &s, int time);

	private:
		unsigned int vacancy;
		int number;
		bool buttons[FLOOR_NUM];
		bool full;
		Direction direction;
		std::multimap<int, Person> people;   // int labels which floor this person is heading for
		int time_delayed;

		vector<int> nextstop;
		vector<Direction> nextdirs;
		int thisfloor;
	};


	class QuanTimer{

	//this is like a control panel of the whole system, it calls update function to 
	//update the states of all elements, including elevator and floor queue 
	//
	//things to do at each time step
	// check elevator state: 
	//    1. if it's running, should it stop at this floor, or keep running
	//	  2. if it's static, should it start to move, which direction it's going to move

	// check floor:
	//    1. if there are new poeple joining the queue: then add people into the queue
	//    2. if the elevator is staying on this floor: then need to load people into elevator
	public:
		QuanTimer(){
			time = 0;
			for (int ii = 0; ii < FLOOR_NUM; ii++)
				floors[ii].Init(ii);
		}

		void insert_person(Person const &p){ plist.push_back(p); }
		void time_step();

		Algorithm_SingleElevator_Simple alg;
		Statistics stat;

	private:
		int time;
		Elevator elevator;  // [4];
		Floor floors[FLOOR_NUM];// [FLOOR_NUM];

		//interfaces with algorithm
		vector<unsigned int> nextStop;
		vector<Direction> upOrDown;

		//buttons, also interface with algorithm
		bool floor_up[FLOOR_NUM];
		bool floor_down[FLOOR_NUM];
		bool elevator_button[FLOOR_NUM];
		
		//update in floor.checkNewArrival
		list<Person> plist;
	};

	
}